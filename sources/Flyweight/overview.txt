GoF's definition:

Use sharing to support large numbers of fine-grained objects efficiently.

The pattern allows:

    to reuse of many objects so, to make the utilization of large numbers of objects more efficient.


Flyweight is an object which can be shared. The trick is to split object state into: intrinsic and extrinsic ones. 
Flyweight stores its intrinsic state, but extrinsic one is kept by the flyweight context. Thus, being reused 
the same object instance can have different aggregate states depending on the given flyweight context.

PHP Example

If we were to build a text editor, it would take unacceptably much of memory to allocate all the objects graphically representing characters in the document. 
Except we use flyweights. Character flyweight stores only character code. All the related attributes are kept by flyweight context.
So, we declare Glyph interface to be implemented by any glyph (character, row, maybe column etc.). 
Row represents a sequence of characters. Logically it is a Composite. GlyphContext is an iterator, which maps glyph sequence 
extracts to some extrinsic state. For an instance, all the glyphs of a sequence from index A till index B are associated with 
Times Roman 12 font. GlyphContext must be kept informed of the current position in the glyph structure during traversal.
E.g. when Row performs insert, GlyphContext::next is called. 
GlyphContext sequence index increments with every Row::insert call.
For Row::render, GlyphContext index is set on the beginning of the sequence and with every Character::render request it iterates.
Thus, Character has GlyphContext with index set up according to the Character location in the sequence. 
During Character rendering GlyphContext::getFont returns the font object we expect. 

As you see GlyphContext acts as
extrinsic state repository. Besides, it's glyph representation context. You can have many GlyphContext instances keeping different 
rendering attributes for the same glyph structure. So by switching context you choose representation strategy for the structure.

Flyweights are created by means a factory, which ensures they are shared properly. 
GlyphFactory caches statically Character instances while they are being created. If instance corresponding to the requested one
 already exists in the cache, it is used instead of creation of a new instance.

JavaScript example

Error log entries can be numerous, though the number of error messages they store is limited.
We can define error message code as intrinsic state of ErrorLogEntry flyweight and datetime stamp as extrinsic state.
Whatever many errors are passed to ErrorLogger, it operates limited set of ErrorLogEntry instances, but
stores datetime stamps in ErrorLogEntryContext. So, the same instances of ErrorLogEntry, but in different contexts provide 
the required information.