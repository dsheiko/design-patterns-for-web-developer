h2. Flyweight

[blockquote:Use sharing to support large numbers of fine-grained objects efficiently.|
Gang of Four|
Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John (1994-10-31). Design Patterns: Elements of Reusable Object-Oriented Software|
http://www.goodreads.com/book/show/85009.Design_Patterns]

[img:doc/Flyweight/uml.png|Flyweight pattern class diagram]

The pattern allows:

* to reuse of many objects so, to make the utilization of large numbers of objects more efficient.

Flyweight is an object which can be shared. The trick is to split object state into: intrinsic and extrinsic ones.
Flyweight stores its intrinsic state, but extrinsic one is kept by the flyweight context. Thus, being reused
the same object instance can have different aggregate states depending on the given flyweight context.

h3. PHP Example

If we were to build a text editor, it would take unacceptably much of memory to allocate all the objects graphically representing characters in the document.
Except we use flyweights. Character flyweight stores only character code. All the related attributes are kept by flyweight context.
So, we declare Glyph interface to be implemented by any glyph (character, row, maybe column etc.).
Row represents a sequence of characters. Logically it is a Composite. [var:GlyphContext] is an iterator, which maps glyph sequence
extracts to some extrinsic state. For an instance, all the glyphs of a sequence from index A till index B are associated with
Times Roman 12 font. [var:GlyphContext] must be kept informed of the current position in the glyph structure during traversal.
E.g. when Row performs insert, [var:GlyphContext::next] is called.
[var:GlyphContext] sequence index increments with every Row::insert call.
For [var:Row::render], [var:GlyphContext] index is set on the beginning of the sequence and with every [var:Character::render] request it iterates.
Thus, Character has [var:GlyphContext] with index set up according to the Character location in the sequence.
During Character rendering [var:GlyphContext::getFont] returns the font object we expect.

As you see [var:GlyphContext] acts as extrinsic state repository.
Besides, it's glyph representation context. You can have many [var:GlyphContext] instances keeping different
rendering attributes for the same glyph structure. So by switching context you choose representation strategy for the structure.

Flyweights are created by means a factory, which ensures they are shared properly.
[var:GlyphFactory] caches statically [var:Character] instances while they are being created. If instance corresponding to the requested one
 already exists in the cache, it is used instead of creation of a new instance.

[img:doc/Flyweight/PHP/uml.png|Flyweight pattern PHP example class diagram]

[code:sources/Flyweight/PHP/tutorial.php|php]

h3. JavaScript Example

Error log entries can be numerous, though the number of error messages they store is limited.
We can define error message code as intrinsic state of [var:ErrorLogEntry] flyweight and datetime stamp as extrinsic state.
Whatever many errors are passed to [var:ErrorLogger], it operates limited set of [var:ErrorLogEntry] instances, but
stores datetime stamps in [var:ErrorLogEntryContext]. So, the same instances of [var:ErrorLogEntry], but in different contexts provide
the required information.

[img:doc/Flyweight/EcmaScript/uml.png|Flyweight pattern EcmaScript example class diagram]

[code:sources/Flyweight/JavaScript/example.js|js]

h3. JSA Example

[code:sources/Flyweight/JSA/example.js|js]

h3. TypeScript Example

[code:sources/Flyweight/TypeScript/example.ts|js]